from __future__ import annotations

from urllib.error import HTTPError
from urllib.request import Request, urlopen
import time


def _post(url: str):
    req = Request(url, method="POST")
    return urlopen(req)


def _extract_video_name_from_dashboard(body: str) -> str:
    marker = "/delete/"
    start = body.index(marker) + len(marker)
    end = body.index("'", start)
    return body[start:end]


def _create_video(server: dict[str, str]) -> str:
    _post(f"{server['base_url']}/capture-now").read()
    _post(f"{server['base_url']}/convert-now").read()

    with urlopen(f"{server['base_url']}/", timeout=3) as response:
        body = response.read().decode("utf-8")

    return _extract_video_name_from_dashboard(body)


def test_dashboard_available_over_http(server):
    with urlopen(f"{server['base_url']}/", timeout=3) as response:
        body = response.read().decode("utf-8")

    assert response.status == 200
    assert "PlantCamera Dashboard" in body
    assert "Images captured:" in body


def test_capture_now_creates_frame_and_reports_notice(server):
    with _post(f"{server['base_url']}/capture-now") as response:
        assert response.url.startswith(f"{server['base_url']}/?notice=OK%3A")

    with urlopen(f"{server['base_url']}/", timeout=3) as response:
        body = response.read().decode("utf-8")

    assert "Images captured: 1" in body


def test_convert_now_creates_video_and_clears_frames(server):
    _post(f"{server['base_url']}/capture-now").read()

    with _post(f"{server['base_url']}/convert-now") as response:
        assert response.url.startswith(f"{server['base_url']}/?notice=OK%3A")

    with urlopen(f"{server['base_url']}/", timeout=3) as response:
        body = response.read().decode("utf-8")

    assert "timelapse_" in body
    assert "Images captured: 0" in body


def test_delete_video_uses_http_endpoint(server):
    file_name = _create_video(server)

    _post(f"{server['base_url']}/delete/{file_name}").read()

    with urlopen(f"{server['base_url']}/", timeout=3) as response:
        body_after = response.read().decode("utf-8")

    assert f"/delete/{file_name}" not in body_after


def test_live_view_endpoint_serves_jpeg(server):
    deadline = time.time() + 5
    while True:
        try:
            with urlopen(f"{server['base_url']}/live.jpg", timeout=3) as response:
                payload = response.read()
                content_type = response.headers.get("Content-Type")
            break
        except HTTPError as error:
            if error.code != 404 or time.time() >= deadline:
                raise
            time.sleep(0.1)

    assert response.status == 200
    assert content_type == "image/jpeg"
    assert payload.startswith(b"\xff\xd8\xff")


def test_video_watch_and_download_endpoints(server):
    file_name = _create_video(server)

    with urlopen(f"{server['base_url']}/videos/{file_name}", timeout=3) as watch:
        watch_body = watch.read()

    assert watch.status == 200
    assert watch.headers.get("Content-Type") == "video/mp4"
    assert watch_body.startswith(b"FAKE-MP4")

    with urlopen(f"{server['base_url']}/download/{file_name}", timeout=3) as download:
        download_body = download.read()

    assert download.status == 200
    assert download.headers.get("Content-Type") == "video/mp4"
    assert download.headers.get("Content-Disposition") == f"attachment; filename={file_name}"
    assert download_body.startswith(b"FAKE-MP4")


def test_convert_now_with_no_images_returns_error_notice(server):
    # First convert drains the startup frame generated by the capture loop.
    _post(f"{server['base_url']}/convert-now").read()

    with _post(f"{server['base_url']}/convert-now") as response:
        final_url = response.url

    assert "notice=ERROR%3A" in final_url
    assert "No%20collected%20images%20available%20for%20conversion." in final_url


def test_missing_video_endpoints_return_404(server):
    missing_name = "does-not-exist.mp4"

    for path in (
        f"/videos/{missing_name}",
        f"/download/{missing_name}",
        f"/delete/{missing_name}",
    ):
        url = f"{server['base_url']}{path}"
        request = Request(url, method="POST") if path.startswith("/delete/") else url
        try:
            urlopen(request, timeout=3)
            raise AssertionError(f"Expected HTTPError for {path}")
        except HTTPError as error:
            assert error.code == 404


def test_convert_now_rejects_tiny_output_and_reports_error(server_with_tiny_video):
    _post(f"{server_with_tiny_video['base_url']}/capture-now").read()

    with _post(f"{server_with_tiny_video['base_url']}/convert-now") as response:
        final_url = response.url

    assert "notice=ERROR%3A" in final_url
    assert "Generated%20video%20file%20is%20too%20small" in final_url

    with urlopen(f"{server_with_tiny_video['base_url']}/", timeout=3) as dashboard:
        body = dashboard.read().decode("utf-8")

    assert "Last encode error:" in body
    assert "Generated video file is too small" in body
    assert "Encode failed:" in body
